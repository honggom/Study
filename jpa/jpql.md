##### JPQL
1. JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.
2. JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
3. JPQL은 결국 SQL로 변환된다. 

##### 페치 조인과 일반 조인의 차이
1. 페치 조인
```sql
select t
from Team t join fetch t.members
where t.name = '팀A'
```

2. 일반 조인
```sql
select t 
from Team t join t.members m
where t.name = '팀A'
```
> 1번에서는 팀과 회원 컬렉션이 한 번에 조회가 된다.
> > 2번에서 팀과 회원 컬렉션을 조인했으므로 회원 컬렉션과 함께 조회할 것으로 기대해선 안 된다.
> JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.

##### 페치 조인의 특징과 한계
> 페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화 할 수 있다.
> 다음처럼 엔티티에 직접 적용하는 로딩 전략은 애플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라 부른다. 페치 조인은
> 글로벌 로딩 전략보다 우선한다. 예를 들어 글로벌 로딩 전략을 지연 로딩으로 설정해도 JPQL에서 페치 조인을 사용하면
> 페치 조인을 적용해서 함께 조회한다.
> > @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략

> 최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다.
> 물론 일부는 빠를 수는 있지만 전체로 보면 사용하지 않는 엔티티를 자주 로딩하므로 오히러 성능에 악영향을 미칠 수 있다.
> 따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적이다.

- 한계
  - 페치 조인 대상에는 별칭을 줄 수 없다.
  - 둘 이상의 컬렉션을 페치할 수 없다.
  - 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.