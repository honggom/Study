##### JPQL
1. JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.
2. JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
3. JPQL은 결국 SQL로 변환된다. 

##### 페치 조인과 일반 조인의 차이
1. 페치 조인
```sql
select t
from Team t join fetch t.members
where t.name = '팀A'
```

2. 일반 조인
```sql
select t 
from Team t join t.members m
where t.name = '팀A'
```
> 1번에서는 팀과 회원 컬렉션이 한 번에 조회가 된다.
> > 2번에서 팀과 회원 컬렉션을 조인했으므로 회원 컬렉션과 함께 조회할 것으로 기대해선 안 된다.
> JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.

##### 페치 조인의 특징과 한계
> 페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화 할 수 있다.
> 다음처럼 엔티티에 직접 적용하는 로딩 전략은 애플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라 부른다. 페치 조인은
> 글로벌 로딩 전략보다 우선한다. 예를 들어 글로벌 로딩 전략을 지연 로딩으로 설정해도 JPQL에서 페치 조인을 사용하면
> 페치 조인을 적용해서 함께 조회한다.
> > @OneToMany(fetch = FetchType.LAZY) // 글로벌 로딩 전략

> 최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다.
> 물론 일부는 빠를 수는 있지만 전체로 보면 사용하지 않는 엔티티를 자주 로딩하므로 오히러 성능에 악영향을 미칠 수 있다.
> 따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적이다.

- 한계
  - 페치 조인 대상에는 별칭을 줄 수 없다.
  - 둘 이상의 컬렉션을 페치할 수 없다.
  - 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.

##### 경로 표현식
> 경로 표현식이라는 것은 쉽게 이야기해사 .(점)을 찍어 객체 그래프를 탐색하는 것이다.
```sql
select m.username
from Member m
  join m.team t
  join m.orders o
where t.name = '팀A'
```
> 위에서 m.username, m.team, m.orders, t.name이 모두 경로 표현식을 사용한 예다.

##### 경로 표현식의 용어 정리
- 상태 필드 : 단순히 값을 저장하기 위한 필드 (필드 or 프로퍼티)
- 연관 필드 : 연관관계를 위한 필드, 임베디드 타입 포함
  - 단일 값 연관 필드 : @ManyToOne, @OnoToOne, 대상이 엔티티
  - 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션

##### 경로 표현식과 특징
- 상태 필드 경로 : 경로 탐색의 끝이다. 더는 탐색할 수 없다.
- 단일 값 연관 경로 : 묵시적으로 내부 조인이 일어난다. 단일 값 연관 경로는 계속 탐색할 수 있다.
- 컬렉션 값 연관 경로 : 묵시적으로 내부 조인이 일어난다. 더는 탐색할 수 없다. 단 FROM 절에서 조인을
통해 별칭을 얻으면 별칭으로 탐색할 수 있다.

##### 경로 탐색을 사용한 묵시적 조인 시 주의사항
- 항상 내부 조인이다.
- 컬렉션은 경로 탐색의 끝이다. 컬렉션에서 경로 탐색을 하려면 명시적으로 조인해서 별칭을 얻어야 한다.
- 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM 절에 영향을 준다.
