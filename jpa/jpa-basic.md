##### 비교
> 데이터베이스는 기본 키의 값으로 로우를 구분한다. 반면에 객체는 동일성 비교와 동등성 비교라는 두 가지 비교 방법이 있다.
- 동일성 비교는 == 비교다 객체 인스턴스의 주소 값을 비교한다.
- 동등성 비교는 equals() 메서드를 사용해서 객체 내부의 값을 비교한다.
> 따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.

##### JPA와 비교
> JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. 그러므로 다음 코드에서 member1과 member2는 동일성 비교에 성공한다.
```java
String memberId = "100";
Member member1 = jpa.find(Member.class, memberId);
Member member2 = jpa.find(Member.class, memberId);

member1 == member2; // true
```

##### 엔티티의 생명주기
- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태

##### 비영속
> 엔티티 객체를 생성한 상태, 순수한 객체 상태이며 아직 저장하지 않았다.
> 따라서 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다. 이것을 비영속 상태라 한다.

##### 영속
> 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장했다. 이렇게 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.
> 이제 회원 엔티티는 비영속 상태에서 영속 상태가 되었다. 결국 영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻이다.

##### 준영속
> 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다. 특정 엔티티를 준영속 상태로 만들려면
> em.detach() 를 호출하면 된다. em.close() 를 호출해서 영속성 컨텍스트를 닫거나 em.close() 를 호출해서 영속성 컨텍스트를 초기화해도
> 영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다.

##### 삭제
> 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.
