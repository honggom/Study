##### 비교
> 데이터베이스는 기본 키의 값으로 로우를 구분한다. 반면에 객체는 동일성 비교와 동등성 비교라는 두 가지 비교 방법이 있다.
- 동일성 비교는 == 비교다 객체 인스턴스의 주소 값을 비교한다.
- 동등성 비교는 equals() 메서드를 사용해서 객체 내부의 값을 비교한다.
> 따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.

##### JPA와 비교
> JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. 그러므로 다음 코드에서 member1과 member2는 동일성 비교에 성공한다.
```java
String memberId = "100";
Member member1 = jpa.find(Member.class, memberId);
Member member2 = jpa.find(Member.class, memberId);

member1 == member2; // true
```

##### 엔티티의 생명주기
- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태

##### 비영속
> 엔티티 객체를 생성한 상태, 순수한 객체 상태이며 아직 저장하지 않았다.
> 따라서 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다. 이것을 비영속 상태라 한다.

##### 영속
> 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장했다. 이렇게 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.
> 이제 회원 엔티티는 비영속 상태에서 영속 상태가 되었다. 결국 영속 상태라는 것은 영속성 컨텍스트에 의해 관리된다는 뜻이다.

##### 준영속
> 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다. 특정 엔티티를 준영속 상태로 만들려면
> em.detach() 를 호출하면 된다. em.close() 를 호출해서 영속성 컨텍스트를 닫거나 em.close() 를 호출해서 영속성 컨텍스트를 초기화해도
> 영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다.

##### 삭제
> 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

--- 

##### 영속성 컨텍스트의 특징
- 영속성 컨텍스트와 식별자 값
> 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 한다.

- 영속성 컨텍스트와 데이터베이스 저장
> 영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까? JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로
> 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시라한다.

--- 

##### 엔티티 조회
> 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다.

##### 1차 캐시에서 조회
> em.find() 를 호출하면 우선 1차 캐시에서 식별자 값으로 엔티티를 찾는다. 만약 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는
> 1차 캐시에서 엔티티를 조회한다.

##### 데이터베이스에서 조회
> 만약 em.find() 를 호출했는데 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 그리고 1차 캐시에 저장한 후에 영속
> 상태의 엔티티를 반환한다.

##### 쓰기 지연
> 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다. 그리고 트랜잭션을
> 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.

##### 변경 감지
> JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다. 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지
> (dirty checking)라 한다.

##### 엔티티 삭제
> 엔티티를 삭제하려면 먼저 삭제 대상 엔티티를 조회해야 한다. em.remove()에 삭제 대상 엔티티를 넘겨주면 엔티티를 삭제한다. 물론 엔티티를 즉시 삭제하는 
> 것이 아니라 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한다. 이후 트랜잭션을 커밋해서 플러시를 호출하면 실제 데이터베이스에 삭제 쿼리를
> 전달한다.